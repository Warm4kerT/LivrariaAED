<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Projeto de Algoritmos e Estrutura de Dados-&gt; Livraria: Page − Descrição de Algoritmos</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Projeto de Algoritmos e Estrutura de Dados-&gt; Livraria
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Page − Descrição de Algoritmos </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li>Algoritmo Número 1: <div class="fragment"><div class="line">ListaCompra vendasNumPeriodo(int mes, int ano){</div>
<div class="line">    Lista P = mainLista;</div>
<div class="line">    ListaCompra final = NULL;</div>
<div class="line">    ListaCompra C = NULL;</div>
<div class="line"> </div>
<div class="line">    while(P!=NULL){</div>
<div class="line">        C = P-&gt;Cli.lista;</div>
<div class="line">        while(C!=NULL){</div>
<div class="line">            if((C-&gt;dataVenda.mes == mes) &amp;&amp; (C-&gt;dataVenda.ano == ano)){</div>
<div class="line">                final = InserirInicioCompra(C-&gt;ISBN, C-&gt;quantidade, C-&gt;precoTotal, C-&gt;dataVenda, final);</div>
<div class="line">            }</div>
<div class="line">            C = C-&gt;Prox;</div>
<div class="line">        }</div>
<div class="line">        P = P-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return final;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Função de procura de compras num dado mês e ano. A função vai iterando na lista de Clientes e verifica cada lista de compras que o cliente contem. Se essa compra pertencer a esse mês e ano então adiciona a uma lista de Compras e no final devolve-a.</li>
<li>Algoritmo Número 2: <div class="fragment"><div class="line">void ultimaVendaLivro(int ISBN){</div>
<div class="line">    Lista P = mainLista;</div>
<div class="line">    ListaCompra C = NULL;</div>
<div class="line">    Data final = newData(0,0,0);</div>
<div class="line">    Data aux;</div>
<div class="line"> </div>
<div class="line">    while(P!=NULL){</div>
<div class="line">        C = P-&gt;Cli.lista;</div>
<div class="line">        while(C!=NULL){</div>
<div class="line">            if(C-&gt;ISBN == ISBN){</div>
<div class="line">                aux = C-&gt;dataVenda;</div>
<div class="line"> </div>
<div class="line">                if( aux.ano &gt; final.ano ){</div>
<div class="line">                    final = aux;</div>
<div class="line">                }else if( aux.ano == final.ano){</div>
<div class="line">                    if( aux.mes &gt; final.mes ){</div>
<div class="line">                        final = aux;</div>
<div class="line">                    }else if( aux.mes == final.mes ){</div>
<div class="line">                        if( aux.dia &gt; final.dia ){</div>
<div class="line">                            final = aux;</div>
<div class="line">                        }else if( aux.dia == final.dia ){</div>
<div class="line">                            final = aux;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }      </div>
<div class="line">            }</div>
<div class="line">            C = C-&gt;Prox;</div>
<div class="line">        } </div>
<div class="line">        P = P-&gt;Prox;      </div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if(final.ano == 0 || final.dia == 0 || final.mes == 0){</div>
<div class="line">        printf(&quot;Nunca foi vendido!\n\n&quot;);</div>
<div class="line">    }else{</div>
<div class="line">        printf(&quot;Ultima compra do Livro %d : %d/%d/%d\n\n&quot;,ISBN,final.dia,final.mes,final.ano);</div>
<div class="line">    }      </div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Esta função procura a mais recente compra de um <a class="el" href="structLivro.html">Livro</a> especificado pelo utilizador. Tal como a função alterior procura em cada lista de Compras de cada <a class="el" href="structCliente.html">Cliente</a>. Se encontrar alguma compra com o ISBN dado pelo Utilizador então guarda essa <a class="el" href="structData.html">Data</a>, até encontrar uma mais recente com esses critérios. No final apresenta a data.</li>
<li>Algoritmo Número 3: <div class="fragment"><div class="line">void quantidadeVendidaCliente(int NIF){</div>
<div class="line">    Lista search = PesquisaPorm(mainLista,NIF);</div>
<div class="line"> </div>
<div class="line">    if(search == NULL){</div>
<div class="line">        printf(&quot;Cliente não encontrado\n\n&quot;);</div>
<div class="line">        return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ListaCompra C = search-&gt;Cli.lista;</div>
<div class="line">    int total = 0;</div>
<div class="line"> </div>
<div class="line">    while(C!=NULL){</div>
<div class="line">        total = total + C-&gt;quantidade;</div>
<div class="line">        C = C-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    printf(&quot;Quantidade vendida ao Cliente %d : %d\n\n&quot;,NIF,total);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Função simples de interpeção, conta o numero de Livros que um <a class="el" href="structCliente.html">Cliente</a> comprou. É invocada um função de pesquisa do <a class="el" href="structCliente.html">Cliente</a> dado pelo Utilizador e esse <a class="el" href="structCliente.html">Cliente</a> e guardado num apontador. Depois iteramos na lista de Compras contando o numero de livros. No final esse valor é apresentado.</li>
<li>Algoritmo Número 4: <div class="fragment"><div class="line">Tree LivrosMaisVendidosK(ListaCompra L, int k){</div>
<div class="line">    ListaCompra P = L;</div>
<div class="line">    ListaCompra T = NULL, searchL = NULL;</div>
<div class="line">    Tree final, searchT;</div>
<div class="line"> </div>
<div class="line">    while(P!=NULL){</div>
<div class="line">        if(PesquisaCompra(P-&gt;ISBN,T)==1){</div>
<div class="line">            searchL = ProcurarAnteriorCompraISBN(P-&gt;ISBN,T)-&gt;Prox;</div>
<div class="line">            searchL-&gt;quantidade = searchL-&gt;quantidade + P-&gt;quantidade;</div>
<div class="line">        }else{</div>
<div class="line">            T = InserirInicioCompra(P-&gt;ISBN, P-&gt;quantidade, P-&gt;precoTotal, P-&gt;dataVenda,T);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        P = P-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    T = bubbleSortCompra(T);</div>
<div class="line"> </div>
<div class="line">    for(int i = k+1; i&gt;=0; i--){</div>
<div class="line">        searchT = searchTreeISBN(mainTree,T-&gt;ISBN);</div>
<div class="line">        final = addNodoTree(final,searchT-&gt;book);</div>
<div class="line">        if(T-&gt;Prox == NULL){</div>
<div class="line">            break;</div>
<div class="line">        }</div>
<div class="line">        T = T-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return final;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Nesta função recebemos já uma lista de Compras do mês e ano especificos e depois fazemos uma "condensação" dessa lista. Isto é removemos compras dos mesmos Livros guardando numa so compra a quantidade total de Livros vendidos numa so compra. Após esse processo organizamos a lista através de um BubbleSort e apresentamos k Livros através do ISBN da <a class="el" href="structCompra.html">Compra</a>.</li>
<li>Algoritmo Número 5: <div class="fragment"><div class="line">int wastedLoopTree(Tree T){</div>
<div class="line"> </div>
<div class="line">    if(T==NULL){</div>
<div class="line">        return 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    int count = 0;</div>
<div class="line"> </div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.titulo));</div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.primAutor));</div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.secAutor));</div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.editora));</div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.area));</div>
<div class="line">    count = count + (30 - strlen(T-&gt;book.idioma));</div>
<div class="line"> </div>
<div class="line">    return wastedLoopTree(T-&gt;left) + wastedLoopTree(T-&gt;right) + count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int wastedMemory(){</div>
<div class="line">    Lista P = mainLista;</div>
<div class="line">    Tree T = mainTree;</div>
<div class="line"> </div>
<div class="line">    int total, clientes = 0, livros = 0;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    while (P!=NULL){</div>
<div class="line">        clientes = clientes + (30 - strlen(P-&gt;Cli.Nome));</div>
<div class="line">        clientes = clientes + (30 - strlen(P-&gt;Cli.MinhaMorada.Casa));</div>
<div class="line">        clientes = clientes + (30 - strlen(P-&gt;Cli.MinhaMorada.Cidade));</div>
<div class="line"> </div>
<div class="line">        P = P-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    livros = wastedLoopTree(T);</div>
<div class="line">    </div>
<div class="line">    total = livros*sizeof(char) + clientes*sizeof(char);</div>
<div class="line">    </div>
<div class="line">    return total;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Estas duas funções trabalham em conjunto para determinar a memória desperdiçada pelas estruturas de dados dos Livros e Clientes. Como o espaço reservado para cada String é a mesma, este calculo é simples de fazer. A primeira função calcula o espaço desperdiçado pela árvore e o segundo calcula o desperdicio dos Clientes e junta os dois valores e devolve a quantidade de bytes desperdiçados.</li>
<li>Algoritmo Número 6: <div class="fragment"><div class="line">Cliente bigSpender(int ano, int mes){</div>
<div class="line">    Lista P = mainLista;</div>
<div class="line">    ListaCompra C = NULL;</div>
<div class="line">    Cliente bigTimeSpender;</div>
<div class="line">    float shmoney = 0, aux = 0;</div>
<div class="line"> </div>
<div class="line">    while (P!=NULL){</div>
<div class="line">        C = P-&gt;Cli.lista;</div>
<div class="line"> </div>
<div class="line">        if(C!=NULL){</div>
<div class="line">            while(C!=NULL){</div>
<div class="line">                if(C-&gt;dataVenda.ano == ano &amp;&amp; C-&gt;dataVenda.mes == mes){</div>
<div class="line">                    aux = aux + C-&gt;precoTotal;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                C = C-&gt;Prox;</div>
<div class="line">            }</div>
<div class="line">            printf(&quot;%s\n&quot;, P-&gt;Cli.Nome);</div>
<div class="line">            if(aux &gt; shmoney){</div>
<div class="line">                shmoney = aux;</div>
<div class="line">                bigTimeSpender = newCliente(0,0,&quot;NULL&quot;,newMorada(&quot;NULL&quot;,&quot;NULL&quot;,0000,000));</div>
<div class="line">                bigTimeSpender = newCliente(P-&gt;Cli.NIF,P-&gt;Cli.telefone,P-&gt;Cli.Nome,P-&gt;Cli.MinhaMorada);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        P = P-&gt;Prox;</div>
<div class="line">    } </div>
<div class="line"> </div>
<div class="line">    return bigTimeSpender;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Esta função procura faz o somatório de valor gasto dos Clientes num dado mês e ano, guardando sempre o maior valor gasto e o <a class="el" href="structCliente.html">Cliente</a> em questão. No final devolve o <a class="el" href="structCliente.html">Cliente</a> que mais gastou nesse período de tempo.</li>
<li>Algoritmo Número 7: <div class="fragment"><div class="line">int numLivrosComprados(Cliente P){</div>
<div class="line">    ListaCompra C = P.lista;</div>
<div class="line">    int numL = 0;</div>
<div class="line"> </div>
<div class="line">    while(C != NULL){</div>
<div class="line">        numL = numL + C-&gt;quantidade;</div>
<div class="line">        C = C-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return numL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Cliente maisLivrosComprados(){</div>
<div class="line">    Lista P = mainLista;</div>
<div class="line">    Cliente cli;</div>
<div class="line">    int aux = 0, final = 0;</div>
<div class="line"> </div>
<div class="line">    while(P != NULL){</div>
<div class="line">        aux = numLivrosComprados(P-&gt;Cli);</div>
<div class="line">        if(final &lt; aux){</div>
<div class="line">            final = aux;</div>
<div class="line">            cli = P-&gt;Cli;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        P = P-&gt;Prox;</div>
<div class="line">    }</div>
<div class="line">    return cli;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Estas duas funções trabalham juntas para determinar que <a class="el" href="structCliente.html">Cliente</a> mais Livros comprou. A primeira determina o numero de Livros comprados por um <a class="el" href="structCliente.html">Cliente</a> expecifico. A segunda é o loop pela Lista de Clientes invocando a primeira função, guardando sempre o maior numero de livros e os eu respetivo <a class="el" href="structCliente.html">Cliente</a>. No final devolve o <a class="el" href="structCliente.html">Cliente</a> com mais Livros comprados.</li>
<li>Algoritmo Número 8: <div class="fragment"><div class="line">int contagemPorAno(Tree T, int ano){</div>
<div class="line">    if(T==NULL){</div>
<div class="line">        return 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if(T-&gt;book.anoPub == ano){</div>
<div class="line">        return contagemPorAno(T-&gt;left,ano)+contagemPorAno(T-&gt;right,ano)+1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return contagemPorAno(T-&gt;left,ano)+contagemPorAno(T-&gt;right,ano);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int anoMaisPublicacoes(){</div>
<div class="line">    int aux = 0, num, anoFinal, anoInicial = 2010;</div>
<div class="line"> </div>
<div class="line">    while (anoInicial&lt;=2021){</div>
<div class="line">        num = contagemPorAno(mainTree,anoInicial);</div>
<div class="line"> </div>
<div class="line">        if(num&gt;aux){</div>
<div class="line">            aux = num;</div>
<div class="line">            anoFinal = anoInicial;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ++anoInicial;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    return anoFinal;</div>
<div class="line">}</div>
</div><!-- fragment --> Explicação: Novamente duas funções que trabalham juntas para atingir um fim. A primeira faz a contagem de Livros num dado ano. A segunda vai verificar a quantidade de Livros para cada ano desde 2010 até 2021, devolvendo no final o ano com mais publicações. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
